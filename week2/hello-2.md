# 함수
-선언: 명령들의 모음
-반환:return 수행한 결과 반환
-중첩함수:특정 함수 내부에서 선언된 함수
-호이스팅(hoisting): 변수나 함수를 호출하거나 접근하는 코드가 함수 선언 코드보다 위에 있음에도 불구하고, 마치 선언코드가 위에 있는 것처럼 동작하는 기능 
-콜백 함수: 함수를 값으로 취급해 변수에 저장 , 다른 함수의 인수로도 전달 가능 
-고차함수(Higher-Order-Function,HOF):콜백함수를 인수로 받는 함수

# 스코프
-변수와 함수는 생성과 동시에 자신에게 접근하거나 호출할 때 일정한 제약의 범위를 가짐, 변수나 함수에 접근하거나 호출할 수 있는 범위
-- 전역,지역 스코프:
    - 변수가 전역 스코프를 가짐→ 해당 변수를 코드 어디에서나 접근 가능 =전역변수
    - 변수가 지역 스코프를 가짐→ 특정 영역에서만 해당 변수에 접근 가능 =지역 변수
- 블록,함수 스코프: 블록(’{}’)을 기준으로 지역 스코프가 결정
    - 블록 스코프: 블록 내부에서 선언한 변수가 갖는 스코프
    - 함수 스코프: 함수 내부에서 선언한 변수가 갖는 스코프
    - var:함수 스코프 有 (이름 중복해도 문제 없어서 헷갈림)
        - → let,const 사용하는 것을 추천
# 객체
-- 객체: 다양한 값을 담는 자료형
- 객체 생성과 프로퍼티(리터럴,생성자)
    - 리터럴:빈 중괄호 사용{}
    - 생성자: ()
    - 프로퍼티: 빈 객체가 아닌 데이터 있는 객체 생성 ,key, value
        - 속성이라는 뜻으로 객체 설명
        - key는문자형을 사용하여 중복해 사용 불가능
        - 객체는 프로퍼티 여러개 가질 수 있고, 콤마로 구분
        - 키가 중복되면 가장 마지막 프로퍼티만 남음
        - 복수의 단어로 이루어진 키 사용하고 싶다면 반드시 따옴표로 묶어줘야함
-- 객체 프로퍼티 다루기
    - 객체=KEY+VALUE
    - 객체에서 프로퍼티를 찾고, 추가하고,삭제하는 등의 모든 연산은 키를 이용해 수행
- 프로퍼티 접근
    - 점 표기법: 객체 뒤에 점 찍고 키를 명시해 value에 접근
    - 괄호 표기법: 이름 뒤에 대괄호 열고 문자열로 키를 명시한후 접근
# 배열
-- 배열 생성자, 배열 리터럴( 문법 간결)
    - 어떤 자료형으로 사용 가능(객체,함수 저장가능,언어가 고정되어 있지 않음)
    
    ```jsx
    let arrA = new Array(); // 배열 생성자
    let arrB = []; // 배열 리터럴
    ```
    
- 배열 인덱스
    - 배열은 키가 있지 않음,인덱스를 객체의 괄호 표기법처럼 사용

# 조건문
- switch문:비교할 조건이  많을 때 사용하는 조건문, 식이나 값을 case문과 비교해 정확히 일치할 때만 수행
    - break문 사용
    - case문에서 수행할 명령 작성
    - default문: 비교하는 식 또는 값이 어떤 case 와도 일치하지 않을 때 수행하는 명령,선택적으로 가능